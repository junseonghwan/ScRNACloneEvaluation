args = commandArgs(trailingOnly=TRUE)

if (length(args) != 1) {
    print("Provide a config file delimeted by tab or space.")
    stop("Terminating...")
}

library(GenomicRanges)
library(ScRNAClone)
library(vcfR)

# We are now going to generate SNV and CNV data in a format recognized by our software.
# For this, we are going to use vcfR package.
# For comparison to PhyloWGS, we will need to ensure that the SNVs that we generate
# are matched in the input generated for PhyloWGS.
# Therefore, we must complete the step to generate input for PhyloWGS before running this script.

chrs <- c(1:22, "X", "Y")
nucleotides <- c("A","C","G","T")

CONFIG_FILE <- as.character(args[1])
#CONFIG_FILE <- "/home/x_seoju/ScRNACloneEvaluation/Laks/PhyloWGS/ConfigPWGS.txt"
#CONFIG_FILE <- "/Users/seonghwanjun/ScRNACloneEvaluation/Laks/PhyloWGS/ConfigPWGSLocal.txt"
config <- read.table(CONFIG_FILE, header=F, as.is = T)
names(config) <- c("Key", "Value")
VCF_PATH <- as.character(config$Value[config$Key == "VCF_PATH"])
PWGS_SNV_PATH <- as.character(config$Value[config$Key == "PHYLOWGS_SNV_PATH"])
TITAN_CNA_FILE <- as.character(config$Value[config$Key == "TITAN_CNA"])
OUTPUT_PATH <- as.character(config$Value[config$Key == "OUTPUT_PATH"])
output_file <- paste(OUTPUT_PATH, "PWGS/snv.txt", sep="/")

# Load the raw VCF file, but this time as a vcf object.
vcf <- read.vcfR(VCF_PATH)
fix <- getFIX(vcf)
fix.df <- data.frame(fix)
fix.df$POS <- as.numeric(as.character(fix.df$POS))
fix.df$CHROM <- as.character(fix.df$CHROM)

# Load input file generated by PhyloWGS.
library(plyr)
pgs <- read.table(PWGS_SNV_PATH, header=T, as.is=TRUE)
pgs.coord <- ldply(strsplit(pgs$gene, "_"), function(row) {
    return(data.frame(CHR=row[1], POS=row[2]))
});
detach("package:plyr", unload = TRUE)
pgs.coord$CHR <- as.character(pgs.coord$CHR)
pgs.coord$POS <- as.numeric(as.character(pgs.coord$POS))

# Extract only the relevant entries.
vcf.gr <- ConstructGranges(fix.df$CHROM, fix.df$POS, width = 0)
pgs.gr <- ConstructGranges(pgs.coord$CHR, pgs.coord$POS, width = 0)
ret <- findOverlaps(vcf.gr, pgs.gr)

vcf.exon <- vcf[ret@from]
vcf.exon.fix.df <- data.frame(getFIX(vcf.exon))
dim(vcf.exon.fix.df)[1] == dim(pgs)[1]

vcf.exon.fix.df$b <- pgs$d - pgs$a
vcf.exon.fix.df$d <- pgs$d

# Let's re-arrange the columns and remove unnecessary columns.
n_snvs <- dim(vcf.exon.fix.df)[1]
ids <- paste("s", 0:(n_snvs-1), sep="")
mean(ids == pgs$id)

snv <- data.frame(ID=ids, CHR=vcf.exon.fix.df$CHROM, POS=vcf.exon.fix.df$POS,
                  REF=vcf.exon.fix.df$REF, ALT=vcf.exon.fix.df$ALT,
                  b=vcf.exon.fix.df$b, d=vcf.exon.fix.df$d)
snv$POS <- as.numeric(as.character(snv$POS))
head(snv)
head(pgs)

# Generate CNV data.
cnv <- read.table(TITAN_CNA_FILE, header=T, as.is = TRUE)
# TitanCNA output seems to be half open intervals , so we +1 for width.
cnv.gr <- ConstructGranges(chr = cnv$Chromosome, start = cnv$Start_Position.bp., width = cnv$End_Position.bp. - cnv$Start_Position.bp. + 1)
snv.gr <- ConstructGranges(chr = as.character(snv$CHR), start = snv$POS, width = 0)
ret <- findOverlaps(snv.gr, cnv.gr)
snv$MajorCN <- rep(1, n_snvs)
snv$MinorCN <- rep(1, n_snvs)
snv$MajorCN[ret@from] <- cnv$Corrected_MajorCN[ret@to]
snv$MinorCN[ret@from] <- cnv$Corrected_MinorCN[ret@to]

write.table(snv, output_file, quote = FALSE, col.names = TRUE, row.names = FALSE, sep="\t")
head(snv)

